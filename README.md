# Compiler-C

一个简单的C语言子集编译器，没有使用SDT。

文件介绍：

- lex.l 为lex文件
- yacc.y 为yacc文件
- core.h 为语法树和中间代码生成所需核心头文件
- structure.h 为树结点和符号表项结构定义

- test 目录为三项功能的测试文件，分别对应 result-\*.txt
- 直接执行 bash test.sh 以使用最新的代码更新所有 result 文件

  - 默认已使用-w 关闭编译警告

## Part1 总体介绍

完成了以下功能：

* 支持注释、声明、赋值(仅`=`)、循环(`while`和`for`)、分支(`if-else`)、IO。

* 运算方面，支持加减乘除模、各类关系运算和逻辑运算。

* 支持类型检查和错误分析。

* 支持部分代码的优化。

除基本要求外，还支持了：

* 变量作用域处理

* 自增和自减运算
* 普通函数调用
* 一维指针(由于只有`int`类型，所以只支持了`int*`类型)。

## Part2 词法分析

>  在所有字符识别完成后，程序中不可能出现的字符(如`$`符号)会被标记为`INVALID`，用以检查不合法的字符。

因为需要进行变量作用域的处理，所以只能在语义分析时才能填写符号表，在词法分析阶段结束时，变量并未添加到符号表，同时词法分析结果的变量地址用符号`~`标记，等待后续过程进行填写。

对于数字、标识符、字符串字面量，`lex`和`yacc`之间传递的内容为一个`Node`类型的指针，`Node`类型同时也是组成语法树的基本单元，其介绍如下：

```c++
class Node
{
public:
	NodeType type; // 主要类型
	SubType subType; // 次要类型
	vector<Node*> children; // 子节点
	long long intValue; // 存储int类型的值
	string strValue;		// 存储字符串类型的值
	int lineno;					// 出现的行号(结束行)
	SymType symType;		// 当前表达式的类型(用于类型检查)
	bool isAssigned = false; // 对于标识符，是否赋值(用于拒绝使用未赋值的变量)
};
```

之所以使用主要类型和次要类型，是出于结构的复杂度考虑的。很多结点的类型并不同，所以需要继承出很多不同的类，但不同类结点存储的内容却是相似的，相比较而言，我们选择使用一个变量指明结点类型，从而避免了很多不必要的继承关系。

在`Node`类中，提供了两个泛化的变量，即`intValue`和`strValue`，分别用于存储整数类型和字符串类型的值，具体存储的内容因情况而变，例如，`strValue`对于标识符而言，存储标识符的名称；对于字符串字面量来说，存储这个字面量；对于一个表达式来说，存储记录表达式结果的临时变量名。

这里展示一个简单实例，对于代码：

```c
int main(){
    int total = 0;
    // return 1;
    return 0;
}
```

词法分析结果为：

```
INT
MAIN
LBS
RBS
LP
INT
ID total 105553144299904
OP_ASSIGN
NUMBER 0
SEMI
RETURN
NUMBER 0
SEMI
RP
```

## Part3 语法分析

我们没有使用语法制导翻译，而是采用了先生成语法树，后生成中间代码的方案。

实际上，我们实现的语法分析部分只完成唯一的工作：构建抽象语法树结构，而不进行其他任何工作。

这里展示一个代码片段的语法树：

```c
int do_it(int n)
{
    return n % 2;
}

int main()
{
    int d = 1;
    int c = do_it(d);
    return 0;
}
```

```
->ROOT(11) # 括号内数字为当前符号在代码中的的结束位置
-->Function|Int(4) # 定义函数do_it
--->ID:do_it(1)
--->Parameters: (4)
---->n|INT(1)
--->Statement>COMPOUND(4)
---->Statement>RET(3)
----->Expression(3)
------>ID:n(3)
------>Operator> % (3)
------>Number:2(3)
-->EntryPoint(11) # 主函数
--->Statement>COMPOUND(11)
---->Statement>DECLARE(8)
----->Type: Int(8)
----->Statement>ASSIGN(8)
------>ID:d(8)
------>Number:1(8)
---->Statement>DECLARE(9)
----->Type: Int(9)
----->Statement>ASSIGN(9)
------>ID:c(9)
------>Statement>CALL(9) # 函数调用
------->ID:do_it(9)
------->Arguments: (9)
-------->ID:d(9)
---->Statement>RET(10)
----->Number:0(10)
```

## Part4 中间代码生成

这一部分是本学期实验的核心部分，借助于语法分析生成的抽象语法树，进行一次`DFS`遍历树结构，遍历过程中进行以下工作：

* 填写符号表
* 类型检查和错误分析
* 生成中间代码

接下来对这三部分进行介绍。

### Part4.1 填写符号表

由于不同作用域下的变量可能重名，所以需要处理变量的作用域问题。考虑到作用域问题本身源自于函数调用和代码块，所以模仿实际函数传参过程，使用一个栈，在`DFS`的过程中处理变量作用域，过程如下：

对于变量，每当进入一个函数或代码块，如遇到声明语句，则将对应变量入栈。当查找某个变量时，自栈顶开始查找。在离开时，将这些变量弹出，并加入符号表中。这样，当`DFS`结束时，栈为空，符号表中保存了所有的变量。

对于函数，由于`C`的函数都是全局的，所以直接加入符号表中。

在对应变量或函数出现时，即可用符号表中的地址回填之前词法分析中空缺的地址。

符号表的内容和语法树结点略有不同，其结构为：

```c++
class Symbol
{
public:
	string id; // 符号名称
	SymType type; // 符号类型
  // 用于类型检查、错误分析
	vector<SymType> sub; // 对于一个函数，这里存储所有参数的类型
	bool isAssigned = false; // 对于标识符，是否被赋值
  // 用于中间代码优化
  string value; // 记录赋值信息
	int assignCnt = 0; // 记录赋值次数
};
```

### Part4.2 类型检查和错误分析

类型检查主要实现了以下几种：

* `int`类型值和`int*`类型值运算检查

  所有算术运算应用的操作数类型必须是`int`，取地址符号作用到`int`类型上，将会变为`int*`，取值符号作用到`int*`类型上将会变为`int`。

* 函数参数和返回值的类型检查

  检查所有函数的参数和返回值，保证参数正确传递，且返回时赋值正确。

* 变量赋值检查(恐慌模式恢复)

  当使用某一个变量时，会检查该变量是否已经被定义，如果没有被定义，或没有定义后没有被赋值，则将会丢弃涉及该变量的语句，继续向下翻译中间代码

语法错误和词法错误是同时处理的，而且不进行区分，因为这两种错误都可以在`Yacc`中体现出来，表现为无法继续进行归约。

以下是对于几种常见错误的输出结果：

* 输入了无效字符(如`~`)

  ```
  [error] Info:syntax error, unexpected INVALID, expecting INT
  [error] Line: 5
  ```

* 函数参数数目不匹配

  ```
  [error]Wrong function call in line 9
  Different number of arguments in defination and call of do_it
  ```

* 函数类型不匹配

  ```
  [error]Wrong function call in line 10
  Different type of No.0 argument in defination and call of do_it
  ```

* 返回值类型不匹配

  ```
  [error]Wrong Return Statement in line 3
  Return value of do_it do not match
  ```

* 类型赋值不正确

  ```
  [error] Type error in line 10
  Different types between = operator.
  ```

### Part4.3生成中间代码

* 基本格式

  使用四元组对中间代码进行表示，由于四元组格式相对固定，这里只进行简单介绍。

  ```c
  (运算符,操作数1,操作数2,结果)
  // 对于表达式i+1，翻译如下：
  (+,&i,1,temp0)
  ```

* 关于循环和判断语句

  生成结果和课程讲授一致，但是生成方案不同。由于生成中间代码时使用了一次单独的`DFS`，在语法树中，每次遍历到一个循环或判断语句，在结束遍历这个语句时，所有的跳转位置均已经出现，可以直接填写，从而不需要使用回填技术。

  这里展示一个代码片段的生成结果：

  ```c
  int main(){
      int total = 0;
      for(int i = 0; i < 5; i++){
          total = total + i;
      }
  }
  ```

  ```
  1 (=,#105553183015200,0,_) # 声明变量total
  2 (=,#105553183015392,0,_) # 声明变量i
  3 (<,#105553183015392,5,temp0)
  4 (IFNZ,temp0,_,6)  # IFNZ 为"If not zero"，即条件为真时跳转到第六行。
  5 (JMP,_,_,12)			# 条件为假时，跳转到第12行，退出循环。
  6 (+,#105553183015200,#105553183015392,temp1)
  7 (=,#105553183015200,temp1,_)
  8 (+,#105553183015392,0,temp2)
  9 (+,#105553183015392,1,temp3)
  10 (=,#105553183015392,temp3,_) # 8-10行为自增运算
  11 (JMP,_,_,3)		  # 跳转到第3行，重新计算表达式
  12 (RET,0,_,_)
  ```
  
* 关于函数调用

  这里假设所有函数都有返回值。

  关于地址分配：所有代码均使用静态分配方案，即每一个被声明的变量都在编译时被分配好空间，由此不支持递归调用，且数据结构不能动态创建。

  ```
  # 声明函数
  (FUNC,do_it,{#105553128636800,},_)  # 此处的地址为已经分配好的地址
  (%,#105553128636800,2,temp0)
  (RET,temp0,_,_)
  (ENDF,do_it,_,_)
  # 调用函数
  (CALL,do_it,{#105553128637376,},temp1) # 可以传递参数地址或字面量
  ```

* 关于自增和自减运算

  将自增自减运算转化为普通的加减运算，例如：对于`i++`和`--i`，分别会翻译为：

  ```
  # i++
  (+,&i,0,temp1)
  (+,1,1,temp2)
  (=,&i,temp2,_)
  # --i
  (-,i,1,temp1)
  (-,i,1,temp2)
  (=,&i,temp2,_)
  ```

  即，将表达式的值和副作用分别处理。

  另外，`temp1`和`temp2`在大多数情况下是多余的，但自增自减运算确实是一个表达式，需要有对应的值，这一点在代码优化中处理。

* 布尔运算的处理

  布尔运算直接按照`假0真1`处理，与算术运算一同处理，最后在条件语句中只需要判断最终表达式的值是否为真。

## Part5 中间代码优化

* 删除未使用的表达式结果

  如果一个表达式的结果没有被使用，则计算这个表达式的中间代码将会被删除，如循环语句中自增自减运算的表达式值。

  这里遍历了中间代码一次，只删除第一层未使用的表达式结果。

* 删除未使用的变量

  > 借助符号中的以下内容进行实现：
  >
  > ```c++
  > string value; // 记录赋值信息
  > int assignCnt = 0; // 记录赋值次数
  > ```

  对于仅定义并赋值一次的非指针变量进行处理

  * 没有被再次使用的变量，将直接删除
  * 被使用的变量，将该变量以常量替代
  * 如果对变量进行了取地址操作，则不进行优化

## Part6 汇编

使用了`nasm`汇编，生成的汇编必须在**SASM**中执行。

中间代码转换为汇编过程进行了两次中间代码序列的遍历，第一次遍历进行变量访存预处理及函数栈帧深度记录，第二次遍历进行汇编代码生成。`eax`、`ebx`寄存器均随取随用，不做备份处理。`IO`部分借助了`SASM`提供的`PRINT`及`GET`指令。

整个过程主要涉及三个部分的工作：

* 变量访存
* 函数调用处理
* 分支跳转

接下来对这三部分进行介绍。

### Part6.1变量访存

考虑到变量作用域问题，为简化访存问题，所有变量均在其定义的函数开始处预分配空间。

函数内定义的变量与生成的临时变量不做区别对待。

变量访存主要利用记录`<变量标识, 入栈深度/ebp偏移量>`的`map`以及记录栈帧深度的`stackDeep`。

第一次遍历中间代码序列时：

* 遇到每个未记录变量时，使`stackDeep`增加空间大小对应的值，同时将函数标识及入栈深度记录在`map`中。

* 遇到函数返回标识`RET`时在`funcStackDeepList`中记录函数栈帧深度，之后`stackDeep`置零。

变量访存涉及局部变量及临时变量、函数参数的访存：

* 局部变量及临时变量访存

  采用以`esp`寄存器为基准的访存策略，根据`map`中记录的变量入栈深度及`funcStackDeepList`中记录的函数栈帧深度即可获取变量空间地址与`esp`寄存器的偏移量。

* 函数参数访存

  采用以`ebp`寄存器为基准的访存策略，处理函数定义标识`FUNC`时记录形参和`ebp`寄存器的偏移量，调用函数前将实参倒序入栈，与记录的偏移量相对应。

### Part6.2函数调用处理

* 参数

  在函数定义处顺序记录形参和`ebp`寄存器的偏移量，在函数调用处将实参倒序入栈，访存时以`ebp`寄存器为基准进行访存。

* 空间

  函数定义起始处进行寄存器备份、`ebp`更新，变量空间预留。函数返回处进行变量空间回收、寄存器还原。其中变量空间大小值已在第一次遍历过程中获取并记录在`funcStackDeepList`中。

* 返回值

  函数返回值记录在`eax`寄存器中供调用者访问。

### Part6.3分支跳转

分支跳转主要涉及跳转目标标识、逻辑表达式两方面的工作。

* 跳转目标标识

  中间代码的跳转位置以行数标识，但由于`nasm`以局部标签名记录跳转目标，故需要为跳转目标添加局部标签。在第一次遍历中遇到`JMP`及`IFNZ`标识时记录跳转目标，第二次遍历为跳转目标添加局部标签，如：

  ```assembly
  .Anchor73:
  	mov eax, [esp+124]
  	mov ebx, dword 1
  	add eax, ebx
  	mov [esp+20], eax
  	mov eax, [esp+20]
  	mov [esp+124], eax
  	jmp .Anchor38
  ```

* 逻辑表达式

  汇编的单次逻辑判断结果保存在众多标志位中，且标志位中的结果不便于直接访问，因此需要借助`JNZ`等一系列条件跳转指令实现逻辑判断结果的保留，此过程产生产生许多仅供逻辑判断使用的跳转目标标识，出于代码阅读的友好性，与作为正式代码的跳转目标标识区别对待，如：

  ```asm
  .tempAnchor21:
  	cmp [esp+44], dword 0
  	jz .tempAnchor22
  	mov [esp+40], dword 1
  	jmp .tempAnchor23
  ```

## Part7 缺陷

* 语法分析部分
  * 语法部分不完善，存在一个移进-归约冲突没有被解决。
* 中间代码生成部分
  * 没有使用语法制导翻译，增加了运行耗时。
  * 错误分析功能有限，错误位置相对欠准确。
* 汇编部分
  * 变量空间以预留方式开辟，没有与实际的分支跳转相联系进行动态的创建、回收，浪费了部分空间，增加了栈帧最大深度。
  * `IO`借助`SASM`提供的`PRINT`、`GET`指令，没有采用系统调用进行实现。
